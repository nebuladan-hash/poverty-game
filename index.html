<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Poverty Card Game üí∞</title>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore-compat.js"></script>

    <style>
        :root { --felt: #1a3a2a; --gold: #FFD700; --red: #d40000; --white: #ffffff; --black: #1a1a1a; --green: #2ecc71; }
        
        body { 
            font-family: 'Segoe UI', Arial, sans-serif; 
            background: #1a3a2a url('https://drive.google.com/thumbnail?id=139Jton5laMVsF3FrIxUDmNM5ttut-mUA&sz=w1920') no-repeat center center fixed;
            background-size: cover;
            color: white; margin: 0; padding: 10px; text-align: center; 
            min-height: 100dvh; overflow-x: hidden; touch-action: manipulation; 
        }

        #game-alert-banner {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9); border: 2px solid var(--gold);
            color: var(--gold); padding: 12px 30px; border-radius: 50px;
            font-weight: 900; z-index: 10001; display: none;
            box-shadow: 0 0 30px rgba(0,0,0,0.8); white-space: nowrap;
            font-size: 1.1rem; text-transform: uppercase; pointer-events: none;
        }

        #drop-player-btn {
            display: none; background: var(--red); color: white;
            padding: 10px 25px; border-radius: 12px; border: 2px solid white;
            font-size: 1rem; font-weight: bold; cursor: pointer;
            margin: 15px auto; animation: pulseRed 1s infinite;
            position: relative; z-index: 100;
        }
        @keyframes pulseRed { 0% { transform: scale(1); box-shadow: 0 0 0px var(--red); } 50% { transform: scale(1.05); box-shadow: 0 0 15px var(--red); } 100% { transform: scale(1); box-shadow: 0 0 0px var(--red); } }

        #showdown-list { width: 100%; max-height: 50vh; overflow-y: auto; margin-bottom: 20px; }
        .showdown-player-row { background: rgba(255,255,255,0.1); border-radius: 10px; margin: 8px 0; padding: 10px; border: 1px solid rgba(255,255,255,0.2); }
        .row-high { border-color: var(--gold); background: rgba(255, 215, 0, 0.15); }
        .row-low { border-color: var(--red); background: rgba(212, 0, 0, 0.15); }
        .showdown-cards { display: flex; gap: 5px; justify-content: center; margin-top: 8px; }
        .showdown-cards .card { width: 60px; height: 85px; font-size: 0.6rem; }
        .showdown-cards .suit-large { font-size: 30px; }
        .showdown-cards .val { font-size: 16px; }

        .drawing-card-anim {
            position: fixed !important; z-index: 10000 !important; pointer-events: none;
            transition: left 0.6s cubic-bezier(0.2, 0.8, 0.2, 1), top 0.6s cubic-bezier(0.2, 0.8, 0.2, 1), transform 0.6s cubic-bezier(0.2, 0.8, 0.2, 1), filter 0.6s ease, opacity 0.6s ease;
            filter: drop-shadow(0 2px 5px rgba(0,0,0,0.5));
        }
        .card-flying { filter: drop-shadow(0 20px 25px rgba(0,0,0,0.6)) !important; transform: scale(1.1) rotate(5deg) !important; }
        .card-ghost { opacity: 0 !important; transition: opacity 0.2s; }

        .card { width: 95px; height: 135px; background: var(--white); color: var(--black); border-radius: 8px; display: inline-block; position: relative; box-shadow: 0 5px 10px rgba(0,0,0,0.5); cursor: pointer; border: 1px solid #ccc; font-family: 'Georgia', serif; }
        .card.red { color: var(--red); }
        .card .index-tl { position: absolute; top: 4px; left: 0; width: 35px; line-height: 0.85; text-align: center; }
        .card .index-br { position: absolute; bottom: 4px; right: 0; width: 35px; line-height: 0.85; text-align: center; transform: rotate(180deg); }
        .card .val { display: block; font-size: 30px; font-weight: 900; } 
        .card .suit-mini { display: block; font-size: 33px; margin-top: -4px; } 
        .card .center-graphic { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; pointer-events: none; }
        .card .suit-large { font-size: 50px; }
        
        #setup-screen, #winner-overlay, #rematch-screen { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.9); backdrop-filter: blur(10px); z-index: 1000; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 20px; }
        #winner-overlay, #rematch-screen { display: none; }
        #victory-canvas { position: fixed; inset: 0; z-index: 1500; pointer-events: none; display: none; }
        #victory-text { position: fixed; top: 40%; left: 50%; transform: translate(-50%, -50%); z-index: 1600; font-size: 3rem; font-weight: 900; color: var(--gold); text-shadow: 0 0 20px #000, 0 0 40px var(--gold); display: none; pointer-events: none; text-align: center; width: 100%; animation: victoryBounce 1s infinite alternate; }
        @keyframes victoryBounce { from { transform: translate(-50%, -50%) scale(1); } to { transform: translate(-50%, -50%) scale(1.1); } }
        
        #knock-animation { position: fixed; inset: 0; z-index: 2000; display: none; flex-direction: column; align-items: center; justify-content: center; pointer-events: none; }
        .fist-bounce { font-size: 150px; animation: fistHit 0.6s cubic-bezier(.17,.67,.83,.67); pointer-events: none; }
        .knock-name { color: var(--gold); font-size: 2.5rem; font-weight: bold; text-shadow: 0 0 20px #000; margin-top: -20px; opacity: 0; animation: nameFade 0.6s forwards; pointer-events: none; }
        
        @keyframes nameFade { 0% { opacity: 0; transform: translateY(20px); } 100% { opacity: 1; transform: translateY(0); } }
        @keyframes fistHit { 0% { transform: scale(0) rotate(-20deg); opacity: 0; } 50% { transform: scale(1.5) rotate(0deg); opacity: 1; } 100% { transform: scale(1); opacity: 0; } }
        .shake { animation: shakeScreen 0.4s; }
        @keyframes shakeScreen { 0%, 100% { transform: translate(0, 0); } 25% { transform: translate(5px, 5px); } 50% { transform: translate(-5px, -5px); } 75% { transform: translate(5px, -5px); } }

        .menu-box { background: rgba(0, 0, 0, 0.7); padding: 30px; border-radius: 20px; border: 2px solid var(--gold); width: 85%; max-width: 350px; }
        .btn-main { background: linear-gradient(180deg, #FFD700 0%, #B8860B 100%); color: #000; padding: 12px 30px; border-radius: 40px; border: none; font-weight: bold; cursor: pointer; font-size: 1.1rem; margin: 8px; }
        input { padding: 12px; border-radius: 8px; border: 1px solid var(--gold); background: rgba(0,0,0,0.5); color: white; margin-bottom: 10px; width: calc(100% - 24px); }
        #leaderboard { display: flex; justify-content: center; flex-wrap: wrap; gap: 8px; margin: 10px auto; max-width: 600px; }
        .player-box { background: rgba(0,0,0,0.65); padding: 8px 12px; border-radius: 12px; min-width: 90px; border: 1px solid rgba(255,255,255,0.2); position: relative; transition: all 0.3s ease; }
        .player-box.turn { border-color: var(--gold); box-shadow: 0 0 12px var(--gold); background: rgba(255, 215, 0, 0.1); }
        .player-box.spectator { opacity: 0.6; border-style: dashed; }
        .player-box.dealer::after { content: 'D'; position: absolute; top: -8px; right: -8px; background: white; color: black; font-size: 0.8rem; width: 22px; height: 22px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid black; box-shadow: 0 2px 4px rgba(0,0,0,0.5); z-index: 10; }
        .coin-container { display: flex; justify-content: center; gap: 3px; margin-top: 4px; }
        .coin-ui { width: 12px; height: 12px; background: var(--gold); border-radius: 50%; border: 1px solid #000; box-shadow: inset 0 0 3px rgba(0,0,0,0.5); }
        .coin-ui.lost { background: rgba(255,255,255,0.1); border-color: rgba(255,255,255,0.2); box-shadow: none; }
        .card-back { background: #b00; background-image: repeating-linear-gradient(45deg, #a00 0, #a00 10px, #c00 10px, #c00 20px); border: 4px solid white; }
        #turn-notice { color: var(--gold); font-weight: bold; font-size: 1.6rem; margin: 10px 0; height: 2rem; text-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
        #chat-messages { flex: 1; overflow-y: auto; padding: 10px; text-align: left; font-size: 0.85rem; scroll-behavior: smooth; }
        #chat-container { width: 95%; max-width: 500px; margin: 10px auto; background: rgba(0,0,0,0.7); border-radius: 15px; border: 1px solid rgba(255,255,255,0.1); display: flex; flex-direction: column; overflow: hidden; height: 160px; }
        #chat-label { background: rgba(255,255,255,0.1); padding: 5px; font-size: 0.75rem; font-weight: bold; color: var(--gold); text-transform: uppercase; letter-spacing: 1px; }
    </style>
</head>
<body id="game-body">

    <div id="game-alert-banner"></div>

    <div id="knock-animation">
        <div class="fist-bounce">üëä</div>
        <div id="knock-player-name" class="knock-name"></div>
    </div>

    <canvas id="victory-canvas"></canvas>
    <div id="victory-text"></div>

    <div id="setup-screen">
        <h1 style="color:var(--gold); font-size: 3rem;">POVERTY üí∞</h1>
        <div id="initial-menu" class="menu-box">
            <input type="text" id="username" placeholder="Player Name" maxlength="10">
            <button class="btn-main" style="width: 100%;" onclick="startCreation()">Create Game</button>
            <button class="btn-main" style="width: 100%; background: #333; color:white;" onclick="showJoinMenu()">Join Game</button>
        </div>
        <div id="join-menu" class="menu-box" style="display:none;">
            <input type="number" id="room-input" placeholder="6-Digit Code">
            <button class="btn-main" style="width:100%;" onclick="joinExisting()">JOIN</button>
            <button class="btn-main" style="width:100%; background:#333; color:white;" onclick="showMainMenu()">BACK</button>
        </div>
    </div>

    <div id="rematch-screen">
        <h1 id="rematch-title" style="color:var(--gold); font-size: 2.2rem; margin: 0;">NEW GAME LOBBY</h1>
        <div id="timer-display" style="font-size: 2.5rem; color: var(--red); font-weight: bold; margin: 10px 0;">60</div>
        <div class="menu-box">
            <div id="lobby-status-list"></div>
            <p id="rematch-prompt" style="margin-bottom: 20px;">Ready for the next game?</p>
            <button id="btn-rematch-yes" class="btn-main" style="width: 100%;" onclick="respondToRematch(true)">YES (JOIN WITH 3 COINS)</button>
            <button id="btn-rematch-no" class="btn-main" style="width: 100%; background: #d40000; color: white;" onclick="respondToRematch(false)">NO (WATCH)</button>
            <button class="btn-main" style="width: 100%; background: #333; color: white; margin-top: 15px;" onclick="location.reload()">LEAVE ROOM</button>
        </div>
    </div>

    <div id="winner-overlay">
        <h2 style="color:var(--gold); font-size: 2.2rem; margin-bottom: 5px;">SHOWDOWN</h2>
        <div id="showdown-list"></div>
        <button class="btn-main" id="next-round-btn" onclick="closeWinner()">DEAL NEXT ROUND</button>
    </div>

    <div id="game-screen" style="display:none;">
        <div style="display: flex; justify-content: space-between; padding: 10px;">
            <div id="room-tag" style="color:var(--gold); font-weight:bold;">ROOM: ---</div>
            <button onclick="location.reload()" style="background:none; border:none; color:var(--red); font-weight:bold; cursor:pointer;">LEAVE</button>
        </div>
        <div id="leaderboard"></div>
        <div id="turn-notice"></div>
        
        <button id="drop-player-btn" onclick="dropActivePlayer()"></button>
        
        <div id="dealer-controls" style="display: none;"><button class="btn-main" style="background:var(--green); color:white;" onclick="dealCards()">DEAL THE CARDS</button></div>
        
        <div id="gameplay-area">
            <div style="margin: 15px 0; display: flex; justify-content: center; gap: 20px;">
                <div id="deck-pile-ui" class="card card-back" onclick="draw('deck')"><div style="color:white; font-size: 11px; margin-top: 55px;">DECK</div><div id="deck-count" style="color:white; font-weight:bold;"></div></div>
                <div id="discard-pile" onclick="draw('discard')"></div>
            </div>
            <div id="active-hand-ui">
                <div style="font-size: 0.9rem; margin-bottom: 5px; color:rgba(255,255,255,0.7)">SCORE: <span id="my-score">0</span></div>
                <div id="my-cards" style="display: flex; justify-content: center; gap: 8px; min-height: 140px;"></div>
                <button id="btn-knock" class="btn-main" style="display:none; background:var(--red); color:white; width: 85%;" onclick="attemptKnock()">üëä KNOCK</button>
            </div>
        </div>
        <div id="spectator-msg" style="display:none; padding: 20px; color: var(--gold); font-weight: bold; background: rgba(0,0,0,0.5); border-radius: 10px;">
            SPECTATING: Waiting for players to join...
            <br><button class="btn-main" style="font-size: 0.8rem; margin-top: 10px; background: #333; color: white;" onclick="location.reload()">LEAVE GAME</button>
        </div>

        <div id="chat-container">
            <div id="chat-label">Game Chat</div>
            <div id="chat-messages"></div>
            <div style="display:flex; padding:5px; gap:5px; background:rgba(0,0,0,0.3)">
                <input type="text" id="chat-input" placeholder="Message..." style="margin:0; width:100%; padding:8px; border-radius:8px; border:none;">
                <button onclick="sendChatMessage()" style="background:var(--gold); border:none; border-radius:8px; padding:0 15px; font-weight:bold;">‚ûú</button>
            </div>
        </div>
    </div>

    <script>
        const firebaseConfig = { apiKey: "AIzaSyAMpw_kmnBOdYvkmm863aI7Hg1gTKPcMrY", authDomain: "poverty-online.firebaseapp.com", projectId: "poverty-online", storageBucket: "poverty-online.firebasestorage.app", messagingSenderId: "121035718856", appId: "1:121035718856:web:c66ccea9946f60636165fd" };
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();

        let myName = ""; let roomCode = ""; let currentLocalState = null; let fireworkTimer = null;
        let lastKnocker = null; let lastMoveId = null;
        let rematchCountdown = null;
        let hasDisplayedFireworks = false;
        let isAnimatingKnock = false; 

        setInterval(() => {
            if (!currentLocalState || isAnimatingKnock) return;
            const dropBtn = document.getElementById('drop-player-btn');
            if (currentLocalState.status === 'playing' || currentLocalState.status === 'knock_round') {
                const elapsed = (Date.now() - (currentLocalState.turnStartTime || Date.now())) / 1000;
                if (elapsed > 30) {
                    dropBtn.style.display = 'block';
                    dropBtn.innerText = `DROP AFK PLAYER: ${currentLocalState.currentTurn.toUpperCase()}`;
                } else { dropBtn.style.display = 'none'; }
            } else { dropBtn.style.display = 'none'; }
        }, 1000);

        function showJoinMenu() { document.getElementById('initial-menu').style.display = 'none'; document.getElementById('join-menu').style.display = 'block'; }
        function showMainMenu() { document.getElementById('initial-menu').style.display = 'block'; document.getElementById('join-menu').style.display = 'none'; }

        async function startCreation() {
            myName = document.getElementById('username').value.trim();
            if (!myName) return alert("Enter Name");
            roomCode = Math.floor(100000 + Math.random() * 900000).toString();
            try {
                await db.collection("games").doc(roomCode).set({
                    status: "waiting", players: {[myName]: {coins: 3, hand: [], eliminated: false, turnsTaken: 0, spectator: false, hasDecided: false}},
                    playerOrder: [myName], currentTurn: "", deck: createDeck(), discardPile: [], host: myName, currentDealer: myName, roundCount: 0, chat: [{user:"SYSTEM", text:`${myName} created the room.`}],
                    lastMove: null, turnStartTime: Date.now(), knocker: null
                });
                connectToFirebase();
            } catch (e) { alert("Error creating game."); }
        }

        async function joinExisting() {
            myName = document.getElementById('username').value.trim();
            roomCode = document.getElementById('room-input').value.trim();
            if (!myName || !roomCode) return alert("Enter Name and Code");
            try {
                const docRef = db.collection("games").doc(roomCode);
                const doc = await docRef.get();
                if (!doc.exists) return alert("Room not found!");
                const data = doc.data();
                const isSpec = data.roundCount > 0;
                await docRef.update({
                    [`players.${myName}`]: { coins: 3, hand: [], eliminated: false, turnsTaken: 0, spectator: isSpec, hasDecided: isSpec },
                    playerOrder: firebase.firestore.FieldValue.arrayUnion(myName),
                    chat: firebase.firestore.FieldValue.arrayUnion({user:"SYSTEM", text:`${myName} joined as ${isSpec?'spectator':'player'}.`})
                });
                connectToFirebase();
            } catch (e) { alert("Error joining game."); }
        }

        function connectToFirebase() {
            document.getElementById('setup-screen').style.display = 'none';
            document.getElementById('game-screen').style.display = 'block';
            document.getElementById('room-tag').innerText = "ROOM: " + roomCode;
            db.collection("games").doc(roomCode).onSnapshot(doc => { 
                if (doc.exists) { 
                    currentLocalState = doc.data(); 
                    handleKnockEvent(currentLocalState);
                    renderGame(currentLocalState);
                    checkLobbyExpiration(currentLocalState);
                }
            });
        }

        function handleKnockEvent(state) {
            if (state.knocker && state.knocker !== lastKnocker) {
                lastKnocker = state.knocker;
                isAnimatingKnock = true; 
                const anim = document.getElementById('knock-animation');
                document.getElementById('knock-player-name').innerText = state.knocker.toUpperCase() + " KNOCKED!";
                requestAnimationFrame(() => {
                    anim.style.display = 'flex';
                    document.getElementById('game-body').classList.add('shake');
                    setTimeout(() => { 
                        anim.style.display = 'none'; 
                        document.getElementById('game-body').classList.remove('shake');
                        isAnimatingKnock = false; 
                        renderGame(currentLocalState); 
                    }, 1400);
                });
            } else if (!state.knocker) { lastKnocker = null; }
        }

        function triggerGameAlert(msg) {
            const banner = document.getElementById('game-alert-banner');
            banner.innerText = msg; banner.style.display = 'block';
            setTimeout(() => { banner.style.display = 'none'; }, 3000);
        }

        function renderGame(state) {
            const me = state.players[myName];
            const isMyTurn = (me && !me.spectator && state.currentTurn === myName && (state.status === 'playing' || state.status === 'knock_round'));
            document.getElementById('turn-notice').innerText = isMyTurn ? "‚òÖ YOUR TURN ‚òÖ" : "";

            const board = document.getElementById('leaderboard'); 
            board.innerHTML = "";
            state.playerOrder.forEach(p => {
                const d = state.players[p];
                const box = document.createElement('div');
                const isCurrentTurn = state.currentTurn === p && (state.status === 'playing' || state.status === 'knock_round');
                box.className = `player-box ${isCurrentTurn ? 'turn' : ''} ${state.currentDealer === p ? 'dealer' : ''} ${d.spectator ? 'spectator' : ''}`;
                let coinsHTML = '<div class="coin-container">';
                if (!d.spectator && !d.eliminated) {
                    if (d.coins === 0) coinsHTML = `<div style="font-size:0.6rem; color:var(--gold); font-weight:bold; margin-top:5px;">ON POVERTY!</div>`;
                    else for(let i=0; i<3; i++) coinsHTML += `<div class="coin-ui ${i >= d.coins ? 'lost' : ''}"></div>`;
                } else if (d.spectator) { coinsHTML = `<div style="font-size:0.55rem; color:#aaa; margin-top:5px;">SPECTATOR</div>`; }
                coinsHTML += '</div>';
                box.innerHTML = `<div style="font-size:0.75rem; font-weight:bold;">${p.toUpperCase()}</div>${d.eliminated ? '<div style="font-size:0.6rem; color:red;">OUT</div>' : coinsHTML}`;
                board.appendChild(box);
            });

            if (isAnimatingKnock) return; 

            if (state.lastMove && state.lastMove.id !== lastMoveId) {
                lastMoveId = state.lastMove.id;
                if (state.lastMove.player !== myName) {
                    const srcStr = state.lastMove.type === 'drawDeck' ? 'the DECK' : 'the DISCARD PILE';
                    triggerGameAlert(`${state.lastMove.player.toUpperCase()} DREW FROM ${srcStr}`);
                }
            }

            document.getElementById('gameplay-area').style.display = (me && !me.spectator && state.status !== "rematch_lobby") ? 'block' : 'none';
            document.getElementById('spectator-msg').style.display = (me && me.spectator && state.status !== "rematch_lobby") ? 'block' : 'none';
            
            const chatBox = document.getElementById('chat-messages');
            const shouldScroll = chatBox.scrollTop + chatBox.offsetHeight >= chatBox.scrollHeight - 20;
            chatBox.innerHTML = (state.chat || []).map(m => `<p style="margin:2px 0;"><b>${m.user}:</b> ${m.text}</p>`).join('');
            if (shouldScroll) { chatBox.scrollTop = chatBox.scrollHeight; }

            document.getElementById('dealer-controls').style.display = (state.status === "waiting" && state.currentDealer === myName) ? 'block' : 'none';
            document.getElementById('deck-count').innerText = (state.deck || []).length;
            document.getElementById('discard-pile').innerHTML = renderCardHTML(state.discardPile[state.discardPile.length - 1]);

            if (me && !me.spectator && me.hand && state.status !== "rematch_lobby") {
                const handDiv = document.getElementById('my-cards'); handDiv.innerHTML = "";
                const score = calculateScore(me.hand);
                document.getElementById('my-score').innerText = score;
                me.hand.forEach((c, i) => {
                    const w = document.createElement('div'); w.innerHTML = renderCardHTML(c);
                    w.firstElementChild.onclick = () => { if(isMyTurn && me.hand.length === 4) playAction('discard', i); };
                    handDiv.appendChild(w);
                });
                const active = state.playerOrder.filter(p => !state.players[p].eliminated && !state.players[p].spectator);
                document.getElementById('btn-knock').style.display = (state.currentTurn === myName && me.hand.length === 3 && state.status === 'playing' && score >= 18 && me.turnsTaken >= 1 && active.every(p => state.players[p].turnsTaken >= 1)) ? 'inline-block' : 'none';
            }

            if (state.status === "game_over") {
                if (!hasDisplayedFireworks) { startVictoryCelebration(state.lastRoundWinners[0]); hasDisplayedFireworks = true; }
            } else if (state.status === "showdown") {
                hasDisplayedFireworks = false;
                document.getElementById('winner-overlay').style.display = "flex";
                const listDiv = document.getElementById('showdown-list');
                listDiv.innerHTML = "";
                state.playerOrder.forEach(pName => {
                    const pData = state.players[pName];
                    if (pData.spectator || pData.eliminated) return;
                    const pScore = calculateScore(pData.hand);
                    const isHigh = state.lastRoundWinners.includes(pName);
                    const isLow = state.lastRoundLosers.includes(pName);
                    const row = document.createElement('div');
                    row.className = `showdown-player-row ${isHigh ? 'row-high' : ''} ${isLow ? 'row-low' : ''}`;
                    let label = "";
                    if (isHigh) label = `<span style="color:var(--gold); font-weight:bold;"> [HIGH]</span>`;
                    if (isLow) label = `<span style="color:var(--red); font-weight:bold;"> [LOW]</span>`;
                    if (pName === state.knocker) label += ` <span style="font-size:0.8rem;">üëä</span>`;
                    row.innerHTML = `<div style="display:flex; justify-content:space-between; align-items:center;"><span style="font-weight:bold;">${pName.toUpperCase()}${label}</span><span style="font-size:1.1rem; color:var(--gold);">${pScore} PTS</span></div><div class="showdown-cards">${(pData.hand || []).map(c => renderCardHTML(c)).join('')}</div>`;
                    listDiv.appendChild(row);
                });
                document.getElementById('next-round-btn').style.display = (state.currentDealer === myName) ? "block" : "none";
            } else if (state.status === "rematch_lobby") {
                document.getElementById('rematch-screen').style.display = "flex";
                document.getElementById('winner-overlay').style.display = "none";
            } else { 
                document.getElementById('winner-overlay').style.display = "none"; 
                document.getElementById('rematch-screen').style.display = "none";
                clearInterval(rematchCountdown);
            }
        }

        async function dropActivePlayer() {
            if (!currentLocalState) return;
            const target = currentLocalState.currentTurn;
            if (confirm(`Drop ${target} for being inactive? They will become a spectator.`)) {
                db.runTransaction(async t => {
                    const docRef = db.collection("games").doc(roomCode), doc = await t.get(docRef), data = doc.data();
                    const pHand = data.players[target].hand || [];
                    data.deck.push(...pHand); data.deck.sort(() => Math.random() - 0.5);
                    data.players[target].spectator = true; data.players[target].hand = []; data.players[target].coins = 0;
                    data.chat.push({user:"SYSTEM", text:`üö´ ${target} was dropped for inactivity.`});
                    let stillIn = data.playerOrder.filter(p => !data.players[p].eliminated && !data.players[p].spectator);
                    if (stillIn.length === 1) {
                        data.status = "game_over"; data.lastRoundWinners = [stillIn[0]];
                        data.chat.push({user:"SYSTEM", text:`üèÜ ${stillIn[0]} wins the game by default!`});
                    } else {
                        if (data.status === "knock_round" && target === data.knocker) { data.status = "showdown"; finalize(data); }
                        else { data.currentTurn = getNext(data); data.turnStartTime = Date.now(); }
                    }
                    t.update(docRef, data);
                });
            }
        }

        function draw(src) { 
            const isTurn = (currentLocalState && (currentLocalState.status === 'playing' || currentLocalState.status === 'knock_round'));
            if(!isTurn || currentLocalState.currentTurn !== myName) return;
            const me = currentLocalState.players[myName];
            if (me.hand && me.hand.length >= 4) return;
            const sourceEl = src === 'deck' ? document.getElementById('deck-pile-ui') : document.getElementById('discard-pile');
            const targetEl = document.getElementById('my-cards');
            if (sourceEl && targetEl) {
                const rect = sourceEl.getBoundingClientRect(), targetRect = targetEl.getBoundingClientRect();
                const flyer = document.createElement('div');
                flyer.className = (src === 'deck') ? 'card card-back drawing-card-anim' : 'card drawing-card-anim';
                if (src === 'discard') flyer.innerHTML = sourceEl.innerHTML;
                flyer.style.width = rect.width + 'px'; flyer.style.height = rect.height + 'px';
                flyer.style.left = rect.left + 'px'; flyer.style.top = rect.top + 'px';
                document.body.appendChild(flyer);
                requestAnimationFrame(() => { requestAnimationFrame(() => {
                    flyer.classList.add('card-flying');
                    flyer.style.left = (targetRect.left + (targetRect.width / 2) - (rect.width / 2)) + 'px';
                    flyer.style.top = targetRect.top + 'px';
                }); });
                setTimeout(() => { flyer.remove(); playAction(src === 'deck' ? 'drawDeck' : 'drawDiscard'); }, 600);
            } else playAction(src === 'deck' ? 'drawDeck' : 'drawDiscard');
        }

        function playAction(action, payload) {
            if (action === "discard") {
                const handCards = document.querySelectorAll('#my-cards .card');
                const targetPile = document.getElementById('discard-pile');
                if (handCards[payload] && targetPile) {
                    const cardEl = handCards[payload], rect = cardEl.getBoundingClientRect(), targetRect = targetPile.getBoundingClientRect();
                    const flyer = cardEl.cloneNode(true);
                    flyer.className = cardEl.className + ' drawing-card-anim';
                    flyer.style.width = rect.width + 'px'; flyer.style.height = rect.height + 'px';
                    flyer.style.left = rect.left + 'px'; flyer.style.top = rect.top + 'px';
                    document.body.appendChild(flyer);
                    requestAnimationFrame(() => { requestAnimationFrame(() => {
                        cardEl.classList.add('card-ghost');
                        flyer.classList.add('card-flying');
                        flyer.style.left = targetRect.left + 'px'; flyer.style.top = targetRect.top + 'px';
                        flyer.style.opacity = '0';
                    }); });
                    setTimeout(() => { flyer.remove(); executeFirebaseAction(action, payload); }, 600);
                    return;
                }
            }
            executeFirebaseAction(action, payload);
        }

        async function executeFirebaseAction(action, payload) {
            if (currentLocalState.currentTurn !== myName && action !== "drop") return;
            db.runTransaction(async t => {
                const docRef = db.collection("games").doc(roomCode), doc = await t.get(docRef), data = doc.data();
                const p = data.players[myName];
                if (data.currentTurn !== myName || p.spectator) return;
                if (action === 'drawDeck' || action === 'drawDiscard') {
                    if (p.hand.length >= 4) return;
                    data.lastMove = { player: myName, type: action, id: Date.now() };
                    data.chat.push({user:"SYSTEM", text:`${myName} drew from ${action === 'drawDeck' ? 'the Deck' : 'the Discard Pile'}.`});
                    const drawnCard = action === 'drawDeck' ? data.deck.pop() : data.discardPile.pop();
                    p.hand.push(drawnCard);
                } else if (action === "discard") {
                    data.discardPile.push(p.hand.splice(payload, 1)[0]); p.turnsTaken++;
                    if (calculateScore(p.hand) === 31) { 
                        data.status = "showdown"; data.knocker = myName; 
                        data.chat.push({user:"SYSTEM", text:`${myName} HIT 31!`});
                        finalize(data); 
                    } else {
                        let next = getNext(data);
                        if (data.status === "knock_round" && next === data.knocker) { data.status = "showdown"; finalize(data); }
                        else { data.currentTurn = next; data.turnStartTime = Date.now(); }
                    }
                } else if (action === "knock") {
                    data.status = "knock_round"; data.knocker = myName; 
                    data.chat.push({user:"SYSTEM", text:`üëä ${myName} KNOCKED!`});
                    // FIX: Explicitly advance turn and reset timer for next person
                    data.currentTurn = getNext(data); 
                    data.turnStartTime = Date.now(); 
                }
                t.update(docRef, data);
            }).catch(e => console.error("Write error:", e));
        }

        function calculateScore(h) { if (!h) return 0; let s = {'H':0,'D':0,'S':0,'C':0}; h.forEach(c => { let v = (c.value === 'A') ? 11 : (['K','Q','J','10'].includes(c.value) ? 10 : parseInt(c.value)); s[c.suit] += v; }); return Math.max(s.H, s.D, s.S, s.C); }
        function createDeck() { const s = ['H','D','S','C'], v = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'], d = []; s.forEach(suit => v.forEach(value => d.push({suit, value}))); return d.sort(() => Math.random() - 0.5); }
        function renderCardHTML(c) { if (!c) return '<div class="card card-back"></div>'; const sym = {'H':'‚ô•','D':'‚ô¶','S':'‚ô†','C':'‚ô£'}[c.suit], face = ['J','Q','K'].includes(c.value) ? (c.value==='J'?'ü§µüèº':c.value==='Q'?'üë∏üèº':'ü§¥üèº') : `<span class="suit-large">${sym}</span>`; return `<div class="card ${c.suit==='H'||c.suit==='D'?'red':''}"><div class="index-tl"><span class="val">${c.value}</span><span class="suit-mini">${sym}</span></div><div class="center-graphic">${face}</div><div class="index-br"><span class="val">${c.value}</span><span class="suit-mini">${sym}</span></div></div>`; }
        function getNext(d) { let a = d.playerOrder.filter(p => !d.players[p].eliminated && !d.players[p].spectator); return a[(a.indexOf(d.currentTurn) + 1) % a.length]; }
        function finalize(d) {
            let s = {}, min = 32, max = -1, a = d.playerOrder.filter(p => !d.players[p].eliminated && !d.players[p].spectator);
            a.forEach(p => { let sc = calculateScore(d.players[p].hand); s[p] = sc; min = Math.min(min, sc); max = Math.max(sc, max); });
            const hit31 = a.some(p => s[p] === 31);
            a.forEach(p => {
                let coinsToLose = 0;
                if (hit31) { if (s[p] < 31) coinsToLose = 1; }
                else { if (s[p] === min) coinsToLose = (p === d.knocker) ? 2 : 1; }
                if (coinsToLose > 0) {
                    const currentCoins = d.players[p].coins;
                    if (p === d.knocker && s[p] === min) { if (currentCoins <= 1) { d.players[p].eliminated = true; d.chat.push({user:"SYSTEM", text:`üíÄ ${p} knocked, lost, and is eliminated!`}); } else { d.players[p].coins -= 2; if(d.players[p].coins === 0) d.chat.push({user:"SYSTEM", text:`üí∞ ${p} is ON POVERTY!`}); } }
                    else { if (currentCoins === 0) { d.players[p].eliminated = true; d.chat.push({user:"SYSTEM", text:`üíÄ ${p} lost on Poverty and is OUT!`}); } else { d.players[p].coins = Math.max(0, currentCoins - coinsToLose); if (d.players[p].coins === 0) d.chat.push({user:"SYSTEM", text:`üí∞ ${p} is ON POVERTY!`}); } }
                }
            });
            d.lastRoundWinners = a.filter(p => s[p] === max); d.lastRoundLosers = a.filter(p => s[p] === min);
            d.highScore = max; d.lowScore = min;
            let stillIn = d.playerOrder.filter(p => !d.players[p].eliminated && !d.players[p].spectator);
            if (stillIn.length === 1) { d.status = "game_over"; d.lastRoundWinners = [stillIn[0]]; d.chat.push({user:"SYSTEM", text:`üèÜ ${stillIn[0]} won the game!`}); return; }
            let nD; for(let i=1; i<=d.playerOrder.length; i++) { let c = d.playerOrder[(d.playerOrder.indexOf(d.currentDealer)+i)%d.playerOrder.length]; if(!d.players[c].eliminated && !d.players[c].spectator) { nD = c; break; } }
            d.currentDealer = nD;
        }

        function startVictoryCelebration(name) {
            const canvas = document.getElementById('victory-canvas'), text = document.getElementById('victory-text');
            canvas.style.display = 'block'; text.style.display = 'block';
            text.innerText = `${name.toUpperCase()} WINS!!!`;
            const ctx = canvas.getContext('2d'); canvas.width = window.innerWidth; canvas.height = window.innerHeight;
            let particles = [];
            function createFirework() {
                const x = Math.random() * canvas.width, y = Math.random() * (canvas.height / 2), color = `hsl(${Math.random() * 360}, 100%, 50%)`;
                for (let i = 0; i < 50; i++) particles.push({ x, y, vx: Math.cos(i) * Math.random() * 5, vy: Math.sin(i) * Math.random() * 5, life: 100, color });
            }
            function animate() {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                if (Math.random() < 0.05) createFirework();
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i]; p.x += p.vx; p.y += p.vy; p.vy += 0.05; p.life--; ctx.fillStyle = p.color;
                    ctx.beginPath(); ctx.arc(p.x, p.y, 2, 0, Math.PI * 2); ctx.fill();
                    if (p.life <= 0) particles.splice(i, 1);
                }
                fireworkTimer = requestAnimationFrame(animate);
            }
            animate();
            setTimeout(() => { cancelAnimationFrame(fireworkTimer); canvas.style.display = 'none'; text.style.display = 'none'; enterRematchLobby(); }, 10000);
        }

        async function enterRematchLobby() { if (currentLocalState.host === myName) await db.collection("games").doc(roomCode).update({ status: "rematch_lobby" }); showRematchUI(); }
        function showRematchUI() {
            document.getElementById('rematch-screen').style.display = 'flex';
            document.getElementById('btn-rematch-yes').style.display = 'block';
            document.getElementById('btn-rematch-no').style.display = 'block';
            document.getElementById('rematch-prompt').innerText = "Ready for the next game?";
            let timeLeft = 60; const timerEl = document.getElementById('timer-display'); timerEl.innerText = timeLeft;
            clearInterval(rematchCountdown);
            rematchCountdown = setInterval(() => {
                timeLeft--; timerEl.innerText = timeLeft;
                if (timeLeft <= 0) { clearInterval(rematchCountdown); if (currentLocalState.host === myName) finalizeLobby(currentLocalState); }
            }, 1000);
        }

        async function respondToRematch(wantsToPlay) {
            const playerUpdate = { [`players.${myName}.spectator`]: !wantsToPlay, [`players.${myName}.eliminated`]: false, [`players.${myName}.hasDecided`]: true, [`players.${myName}.hand`]: [], chat: firebase.firestore.FieldValue.arrayUnion({user:"SYSTEM", text:`${myName} is ${wantsToPlay?'entering the game':'spectating'}.`}) };
            if (wantsToPlay) playerUpdate[`players.${myName}.coins`] = 3; else playerUpdate[`players.${myName}.coins`] = 0;
            await db.collection("games").doc(roomCode).update(playerUpdate);
            document.getElementById('btn-rematch-yes').style.display = 'none'; document.getElementById('btn-rematch-no').style.display = 'none';
            document.getElementById('rematch-prompt').innerText = wantsToPlay ? "You're in! Waiting for others..." : "Watching this one.";
        }

        async function finalizeLobby(state) {
            const players = {...state.players}, active = state.playerOrder.filter(p => players[p] && !players[p].spectator && !players[p].eliminated);
            if (active.length < 2) return;
            const lastWinner = state.lastRoundWinners ? state.lastRoundWinners[0] : null;
            let dealer = (lastWinner && active.includes(lastWinner)) ? lastWinner : active[Math.floor(Math.random() * active.length)];
            state.playerOrder.forEach(p => { if(players[p]) players[p].hasDecided = false; });
            await db.collection("games").doc(roomCode).update({ status: "waiting", currentDealer: dealer, players: players, chat: firebase.firestore.FieldValue.arrayUnion({user:"SYSTEM", text:`Rematch Ready! Dealer: ${dealer}. Click 'Deal' to begin.`}) });
        }

        async function dealCards() {
            await db.runTransaction(async t => {
                const docRef = db.collection("games").doc(roomCode), doc = await t.get(docRef), data = doc.data(), players = {...data.players}, active = data.playerOrder.filter(p => players[p] && !players[p].spectator && !players[p].eliminated);
                if (active.length < 2) return;
                const deck = createDeck();
                active.forEach(p => { players[p].hand = [deck.pop(), deck.pop(), deck.pop()]; players[p].turnsTaken = 0; });
                let dealer = (data.roundCount === 0) ? data.host : data.currentDealer;
                const firstPlayer = active[(active.indexOf(dealer) + 1) % active.length];
                t.update(docRef, { status: "playing", currentTurn: firstPlayer, currentDealer: dealer, deck, discardPile: [deck.pop()], players, roundCount: data.roundCount + 1, knocker: null, lastMove: null, turnStartTime: Date.now(), chat: firebase.firestore.FieldValue.arrayUnion({user:"SYSTEM", text:`Round ${data.roundCount + 1} started. Dealer: ${dealer}. First to act: ${firstPlayer}`}) });
            });
        }

        function sendChatMessage() { const input = document.getElementById('chat-input'); if (!input.value.trim()) return; db.collection("games").doc(roomCode).update({ chat: firebase.firestore.FieldValue.arrayUnion({ user: myName, text: input.value.trim() }) }); input.value = ""; }
        function closeWinner() { db.collection("games").doc(roomCode).update({ status: "waiting" }); }
        function attemptKnock() { playAction('knock'); }
        function checkLobbyExpiration(state) {
            if (state.status === "rematch_lobby") {
                const players = Object.values(state.players);
                const allDecided = players.every(p => p.hasDecided === true);
                const statusListEl = document.getElementById('lobby-status-list');
                if (statusListEl) {
                    statusListEl.innerHTML = Object.entries(state.players).map(([name, data]) => {
                        let statusText = '<span class="status-waiting">DECIDING...</span>';
                        if (data.hasDecided) {
                            statusText = data.spectator ? '<span class="status-watch">WATCHING</span>' : '<span class="status-ready">READY!</span>';
                        }
                        return `<div class="status-row"><span>${name.toUpperCase()}</span> ${statusText}</div>`;
                    }).join('');
                }
                if (allDecided && state.host === myName) finalizeLobby(state);
            }
        }
    </script>
</body>
</html>
</body>
</html>
